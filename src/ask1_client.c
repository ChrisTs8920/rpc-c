/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "ask1.h"
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h> 
#include <netinet/in.h>
#include <unistd.h>


void
op_prog_1(char *host, int choice, float r, int n, int X[], int Y[], int newsockfd)
{
	CLIENT *clnt;
	int  *result_1;
	inputpair  in_prod_1_arg;
	output_avg  *result_2;
	inputpair  avg_1_arg;
	output_prod_r  *result_3;
	inputpair  prod_r_1_arg;

#ifndef	DEBUG
	clnt = clnt_create (host, OP_PROG, OP_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	if (choice == 1) {
		//prepare input struct
		in_prod_1_arg.n = n;
		in_prod_1_arg.X.X_len = n;
		in_prod_1_arg.X.X_val = (int *) malloc(n * sizeof(int));
		in_prod_1_arg.Y.Y_len = n;
		in_prod_1_arg.Y.Y_val = (int *) malloc(n * sizeof(int));

		//fill input struct's X and Y
		for (int i = 0; i < n; i++) {
			in_prod_1_arg.X.X_val[i] = X[i];
			in_prod_1_arg.Y.Y_val[i] = Y[i];
		}

		//call rpc server for result
		result_1 = in_prod_1(&in_prod_1_arg, clnt);
		if (result_1 == (int *) NULL) {
			clnt_perror (clnt, "call failed");
		}

		write(newsockfd, result_1, sizeof(int)); //send result to client

		free(in_prod_1_arg.X.X_val);
		free(in_prod_1_arg.Y.Y_val);
	}

	if (choice == 2) {
		//prepare input struct
		avg_1_arg.n = n;
		avg_1_arg.X.X_len = n;
		avg_1_arg.X.X_val = (int *) malloc(n * sizeof(int));
		avg_1_arg.Y.Y_len = n;
		avg_1_arg.Y.Y_val = (int *) malloc(n * sizeof(int));

		//fill input struct's X and Y
		for (int i = 0; i < n; i++) {
			avg_1_arg.X.X_val[i] = X[i];
			avg_1_arg.Y.Y_val[i] = Y[i];
		}

		//call rpc server for result
		result_2 = avg_1(&avg_1_arg, clnt);
		if (result_2 == (output_avg *) NULL) {
			clnt_perror (clnt, "call failed");
		}

		write(newsockfd, result_2->avg.avg_val, 2 * sizeof(float)); //send result to client

		free(avg_1_arg.X.X_val);
		free(avg_1_arg.Y.Y_val);
	}

	if (choice == 3) {
		//prepare input struct
		prod_r_1_arg.n = n;
		prod_r_1_arg.r = r;
		prod_r_1_arg.X.X_len = n;
		prod_r_1_arg.X.X_val = (int *) malloc(n * sizeof(int));
		prod_r_1_arg.Y.Y_len = n;
		prod_r_1_arg.Y.Y_val = (int *) malloc(n * sizeof(int));

		//fill input struct's X and Y
		for (int i = 0; i < n; i++) {
			prod_r_1_arg.X.X_val[i] = X[i];
			prod_r_1_arg.Y.Y_val[i] = Y[i];
		}

		//call rpc server for result
		result_3 = prod_r_1(&prod_r_1_arg, clnt);
		if (result_3 == (output_prod_r *) NULL) {
			clnt_perror (clnt, "call failed");
		}

		write(newsockfd, result_3->arr.arr_val, n * sizeof(float)); //send result to client

		free(prod_r_1_arg.X.X_val);
		free(prod_r_1_arg.Y.Y_val);
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}

void error(char *msg)
{
    perror(msg);
    exit(1);
}

int
main (int argc, char *argv[])
{
	char *host;
	int sockfd, newsockfd, portno, clilen;
    pid_t procId;
    struct sockaddr_in serv_addr, cli_addr;
    unsigned int children = 0;

	int choice;
	float r; 
	int n;
	int *X;
	int *Y;

	if (argc < 3) {
		printf("usage: %s server_host portno\n", argv[0]);
		exit(1);
	}

	sockfd = socket(AF_INET, SOCK_STREAM, 0); 
    if (sockfd < 0) 
        error("ERROR opening socket");

    bzero((char *) &serv_addr, sizeof(serv_addr));
    portno = atoi(argv[2]);
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(portno);
    serv_addr.sin_addr.s_addr = INADDR_ANY;

    if (bind(sockfd, (struct sockaddr *) &serv_addr,
        	sizeof(serv_addr)) < 0)
                error("ERROR on binding");
    listen(sockfd,5);
	
	host = argv[1];
	for (;;)  {
     	printf("Waiting for a connection...\n");
    	clilen = sizeof(cli_addr);
     	newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
     	if (newsockfd < 0) 
          	error("ERROR on accept");

     	if (fork() == 0)  { //child process
     		close(sockfd); 
        	printf("Connected.\n");
			read(newsockfd, &choice, sizeof(int)); //read choice
			read(newsockfd, &r, sizeof(float));//read r
	        read(newsockfd, &n, sizeof(int));  //read n

			X = (int*)malloc(n * sizeof(int));
    		Y = (int*)malloc(n * sizeof(int));
			read(newsockfd, X, n * sizeof(int)); //read X
    		read(newsockfd, Y, n * sizeof(int)); //read Y

			op_prog_1(host, choice, r, n, X, Y, newsockfd); //calculate result && sent to client

			free(X);
			free(Y);
        	exit (0); 
	}
     	close(newsockfd);
	children++;
	while (children) {
            procId=waitpid((pid_t) -1, NULL, WNOHANG);
	    	if (procId<0) error("waitpid error");
	    	else if (procId==0) break;
	    	else printf("to mazepsa\n");
		}
    }

	exit (0);
}